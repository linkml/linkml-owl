{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"linkml-owl A framework for translating LinkML instance data to OWL Ontologies (TBoxes and ABoxes) LinkML is a general purpose data modeling language for authoring schemas to structure data. The perspective of linkml-owl is that elements of an OWL ontology (in particular, classes) are data elements that should conform to a schema","title":"Introduction"},{"location":"#linkml-owl","text":"A framework for translating LinkML instance data to OWL Ontologies (TBoxes and ABoxes) LinkML is a general purpose data modeling language for authoring schemas to structure data. The perspective of linkml-owl is that elements of an OWL ontology (in particular, classes) are data elements that should conform to a schema","title":"linkml-owl"},{"location":"basics/","text":"Basics First specify your schema using LinkML. Note that LinkML classes will typically be metaclasses at the OWL level. A very simple schema for an anatomical ontology like Uberon: classes: Class: slots: - id - label class_uri: owl:Class AnatomicalEntityClass: is_a: Class slots: - part_of slot_usage: range: AnatomicalEntityClass slots: label: slot_uri: rdfs:label annotations: owl: AnnotationAssertion part_of: slot_uri: BFO:0000050 annotations: owl: SubClassOf, ObjectSomeValuesFrom Then provide OWL classes as LinkML data instances using any of the standard ways of providing data in LinkML (see working with data ) For example, as TSV or YAML: - id: UBERON:1 label: eye part_of: ['UBERON:2'] - id: UBERON:2 label: head part_of: ['UBERON:3'] - id: UBERON:3 label: organism then run this through the command line tool to generate an ontology linkml-data2owl -C AnatomicalEntityClass -s my_schema.yaml my_data.yaml -o my_ont.ofn This generates: AnnotationAssertion(rdfs:label UBERON:1 \"eye\") AnnotationAssertion(rdfs:label UBERON:2 \"head\") AnnotationAssertion(rdfs:label UBERON:3 \"organism\") SubClassOf( UBERON:1 ObjectSomeValuesFrom( BFO:0000050 UBERON:2)) SubClassOf( UBERON:2 ObjectSomeValuesFrom( BFO:0000050 UBERON:3)) Type designator The -C option can be omitted if you explicitly declare the (meta)class being instantiated in the file, either using @type or an slot declared a type_designator. - id: UBERON:1 \"@type\": AnatomicalEntityClass label: eye part_of: ['UBERON:2'] - id: UBERON:2 \"@type\": AnatomicalEntityClass label: head part_of: ['UBERON:3'] - id: UBERON:3 \"@type\": AnatomicalEntityClass label: organism This can be useful when you have a heterogeneous collection of objects. More examples See examples for a complete set of examples/conformance suite","title":"Basics"},{"location":"basics/#basics","text":"First specify your schema using LinkML. Note that LinkML classes will typically be metaclasses at the OWL level. A very simple schema for an anatomical ontology like Uberon: classes: Class: slots: - id - label class_uri: owl:Class AnatomicalEntityClass: is_a: Class slots: - part_of slot_usage: range: AnatomicalEntityClass slots: label: slot_uri: rdfs:label annotations: owl: AnnotationAssertion part_of: slot_uri: BFO:0000050 annotations: owl: SubClassOf, ObjectSomeValuesFrom Then provide OWL classes as LinkML data instances using any of the standard ways of providing data in LinkML (see working with data ) For example, as TSV or YAML: - id: UBERON:1 label: eye part_of: ['UBERON:2'] - id: UBERON:2 label: head part_of: ['UBERON:3'] - id: UBERON:3 label: organism then run this through the command line tool to generate an ontology linkml-data2owl -C AnatomicalEntityClass -s my_schema.yaml my_data.yaml -o my_ont.ofn This generates: AnnotationAssertion(rdfs:label UBERON:1 \"eye\") AnnotationAssertion(rdfs:label UBERON:2 \"head\") AnnotationAssertion(rdfs:label UBERON:3 \"organism\") SubClassOf( UBERON:1 ObjectSomeValuesFrom( BFO:0000050 UBERON:2)) SubClassOf( UBERON:2 ObjectSomeValuesFrom( BFO:0000050 UBERON:3))","title":"Basics"},{"location":"basics/#type-designator","text":"The -C option can be omitted if you explicitly declare the (meta)class being instantiated in the file, either using @type or an slot declared a type_designator. - id: UBERON:1 \"@type\": AnatomicalEntityClass label: eye part_of: ['UBERON:2'] - id: UBERON:2 \"@type\": AnatomicalEntityClass label: head part_of: ['UBERON:3'] - id: UBERON:3 \"@type\": AnatomicalEntityClass label: organism This can be useful when you have a heterogeneous collection of objects.","title":"Type designator"},{"location":"basics/#more-examples","text":"See examples for a complete set of examples/conformance suite","title":"More examples"},{"location":"comparison/","text":"Relationship to OWL template languages Although LinkML is robust and stable, LinkML-OWL is alpha software and incomplete. For now, to convert from TSV to OWL you should for now use a dedicated environment: dosdp-tools robot-templates ottr For most purposes, these frameworks are also simpler and less overhead, they treat ontology generation as a string templating problem, and the emphasis is on the generation of axioms from templates over formal descriptions of the source input file. In contrast, linkml-owl leverages the linkml framework for rich modeling of the source data structures used to generate the ontology, in particular: Clear computable description of cardinality which columns are required, which columns are multivalued etc Ability to use arbitrarily nested JSON trees or RDF graphs as input TSVs can still be used for \"flat\" schemas Use of semantic enumerations for example, a field value may be restricted to two ontology terms such as \"off\" or \"on\" Translation of source schema to other formalisms such as JSON-Schema, JSON-LD Contexts, shape languages, SQL, ... Flexible validation of source input files leveraging any combination of JSON-Schema, SHACL, or ShEx Powerful abilities to infer missing values For example, populate a stereotypical textual definition based on slot values Generation of markdown documentation from source schemas An example of a domain where this kind of rich data modeling of input data includes generation of chemical entity ontologies from data. See the chemrof project. The overall philosophy of linkml-owl is composability of distinct parts . It is a relatively lightweight library that is only concerned with mapping or templating from a source dataset to OWL. It delegates other aspects to other libraries, in particular the following are seen as separate concerns: Validation of input Organizing templates hierarchically Specifying complex rules for inferring membership of a template Template reuse, including reuse of core slots, and an import mechanism Generation of documentation Automatic filling in of default values, and checking of consistency between dependent values Lexical manipulation, including pre-populating labels, synomyms, and text definitions","title":"Comparison with other frameworks"},{"location":"comparison/#relationship-to-owl-template-languages","text":"Although LinkML is robust and stable, LinkML-OWL is alpha software and incomplete. For now, to convert from TSV to OWL you should for now use a dedicated environment: dosdp-tools robot-templates ottr For most purposes, these frameworks are also simpler and less overhead, they treat ontology generation as a string templating problem, and the emphasis is on the generation of axioms from templates over formal descriptions of the source input file. In contrast, linkml-owl leverages the linkml framework for rich modeling of the source data structures used to generate the ontology, in particular: Clear computable description of cardinality which columns are required, which columns are multivalued etc Ability to use arbitrarily nested JSON trees or RDF graphs as input TSVs can still be used for \"flat\" schemas Use of semantic enumerations for example, a field value may be restricted to two ontology terms such as \"off\" or \"on\" Translation of source schema to other formalisms such as JSON-Schema, JSON-LD Contexts, shape languages, SQL, ... Flexible validation of source input files leveraging any combination of JSON-Schema, SHACL, or ShEx Powerful abilities to infer missing values For example, populate a stereotypical textual definition based on slot values Generation of markdown documentation from source schemas An example of a domain where this kind of rich data modeling of input data includes generation of chemical entity ontologies from data. See the chemrof project. The overall philosophy of linkml-owl is composability of distinct parts . It is a relatively lightweight library that is only concerned with mapping or templating from a source dataset to OWL. It delegates other aspects to other libraries, in particular the following are seen as separate concerns: Validation of input Organizing templates hierarchically Specifying complex rules for inferring membership of a template Template reuse, including reuse of core slots, and an import mechanism Generation of documentation Automatic filling in of default values, and checking of consistency between dependent values Lexical manipulation, including pre-populating labels, synomyms, and text definitions","title":"Relationship to OWL template languages"},{"location":"examples/","text":"linkml-owl Test Cases These examples are generated automatically from test_owl_dumper For the complete schema, see tests/input/owl_dumper_test.yaml Annotation using literals Description : Default is to use an annotation assertion, and if the range is a string then this is literal Schema : id: http//example.org/Annotation-using-literals classes: NamedThing: is_a: Thing attributes: id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a label: foo Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( rdfs:label <http://example.org/a> \"foo\" ) ) Annotation using IRIs Description : As above, but if the range is an instance of a LinkML class then use a literal Schema : id: http//example.org/Annotation-using-IRIs classes: ExactMatch: is_a: NamedThing attributes: exactMatch: annotations: owl: AnnotationAssertion slot_uri: skos:exactMatch range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a exactMatch: x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( <http://www.w3.org/2004/02/skos/core#exactMatch> <http://example.org/a> <http://example.org/b> ) ) Annotation using forced literals Description : We can force a literal by imposing a range Schema : id: http//example.org/Annotation-using-forced-literals classes: ExactMatchAsLiteral: is_a: NamedThing attributes: exactMatch: annotations: owl: AnnotationAssertion slot_uri: skos:exactMatch range: string required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a exactMatch: x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( <http://www.w3.org/2004/02/skos/core#exactMatch> <http://example.org/a> \"x:b\" ) ) Basic SubClassOf between named classes Description : _Adding SubClassOf annotation to the linkml class forces a SubClass axiom _ Schema : id: http//example.org/Basic-SubClassOf-between-named-classes classes: Child: is_a: NamedThing attributes: subclass_of: annotations: owl: SubClassOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> <http://example.org/b> ) ) basic direct equivalence between named classes Description : Adding EquivalentTo annotation to the linkml class forces a SubClass axiom Schema : id: http//example.org/basic-direct-equivalence-between-named-classes classes: DirectEquivalent: is_a: NamedThing attributes: equivalent_to: annotations: owl: EquivalentClasses slot_uri: owl:equivalentClasses multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a equivalent_to: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> <http://example.org/b> ) ) SubClassOf SomeValuesFrom Description : A SubClassOf annotation makes the annotation type be subclass, a SomeValuesFrom annotation makes the slot interpreted as an existential Schema : id: http//example.org/SubClassOf-SomeValuesFrom classes: Part: is_a: NamedThing attributes: part_of: annotations: owl: ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a part_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) ) SubClassOf AllValuesFrom Description : As above, but with universal restrictions Schema : id: http//example.org/SubClassOf-AllValuesFrom classes: PartOnly: is_a: NamedThing attributes: part_of: annotations: owl: ObjectAllValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a part_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectAllValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) ) SubClassOf SomeValuesFrom plus label Description : Demonstrates a mix of slots, some annotation, some logical Schema : id: http//example.org/SubClassOf-SomeValuesFrom-plus-label classes: Part: is_a: NamedThing attributes: part_of: annotations: owl: ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a label: foo part_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( rdfs:label <http://example.org/a> \"foo\" ) SubClassOf( <http://example.org/a> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) ) SubClassOf Union Description : The slot is interpreted as a parent class, and all slot values with a UnionOf annotation are collected to make a UnionOf expression Schema : id: http//example.org/SubClassOf-Union classes: ChildOfUnion: is_a: NamedThing attributes: subclass_of: annotations: owl: SubClassOf, UnionOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectUnionOf( <http://example.org/b> <http://example.org/c> ) ) ) EquivalentTo Union Description : As above, but with equivalence Schema : id: http//example.org/EquivalentTo-Union classes: EquivUnion: is_a: NamedThing attributes: operands: annotations: owl: EquivalentClasses, UnionOf multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a operands: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> ObjectUnionOf( <http://example.org/b> <http://example.org/c> ) ) ) EquivalentTo IntersectionOf Description : The slot is interpreted as a parent class, and all slot values with a IntersectionOf annotation are collected to make a IntersectionOf expression Schema : id: http//example.org/EquivalentTo-IntersectionOf classes: EquivIntersection: is_a: NamedThing attributes: operands: annotations: owl: EquivalentClasses, IntersectionOf multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a operands: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> ObjectIntersectionOf( <http://example.org/b> <http://example.org/c> ) ) ) EquivalentTo Genus and SomeValuesFrom Description : All slot value interpretations are collected into a single IntersectionOf Schema : id: http//example.org/EquivalentTo-Genus-and-SomeValuesFrom classes: EquivGenusAndPartOf: is_a: NamedThing attributes: subclass_of: annotations: owl: EquivalentClasses, IntersectionOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true part_of: annotations: owl: EquivalentClasses, IntersectionOf, ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true other_part_ofs: annotations: owl: ObjectSomeValuesFrom description: for hidden GCIs slot_uri: BFO:0000050 multivalued: true range: NamedThing required: false id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - X:genus part_of: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> ObjectIntersectionOf( <http://example.org/genus> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/c> ) ) ) ) Hidden GCI Description : Demonstrates a case where some slots contribute to a logical definition (equiv axiom), and other contribute to additional axioms (so called hidden GCIs) Schema : id: http//example.org/Hidden-GCI classes: EquivGenusAndPartOf: is_a: NamedThing attributes: subclass_of: annotations: owl: EquivalentClasses, IntersectionOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true part_of: annotations: owl: EquivalentClasses, IntersectionOf, ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true other_part_ofs: annotations: owl: ObjectSomeValuesFrom description: for hidden GCIs slot_uri: BFO:0000050 multivalued: true range: NamedThing required: false id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - X:genus part_of: - x:b other_part_ofs: - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/c> ) ) EquivalentClasses( <http://example.org/a> ObjectIntersectionOf( <http://example.org/genus> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) ) ) slot-value level fstring template Description : Axiom generation per slot-value assignment. (Note that currently non-identifier fields have their URIs expanded, but the OWL is the same) Schema : id: http//example.org/slot-value-level-fstring-template classes: ClassTemplateExample1: is_a: NamedThing attributes: subclass_of: annotations: owl.fstring: tag: owl.fstring value: SubClassOf({id} {V}) slot_uri: rdfs:subclass_of multivalued: true range: NamedThing part_of: slot_uri: BFO:0000050 multivalued: true range: NamedThing other_part_ofs: slot_uri: BFO:0000050 multivalued: true range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:a <http://example.org/b> ) ) slot-value level jinja template Description : Axiom generation per slot-value assignment. (Note that currently non-identifier fields have their URIs expanded, but the OWL is the same) Schema : id: http//example.org/slot-value-level-jinja-template classes: ClassTemplateExample2: is_a: NamedThing attributes: subclass_of: annotations: owl.template: tag: owl.template value: '{% for p in subclass_of %}SubClassOf({{id}} {{p}}){% endfor %}' slot_uri: rdfs:subclass_of multivalued: true range: NamedThing part_of: slot_uri: BFO:0000050 multivalued: true range: NamedThing other_part_ofs: slot_uri: BFO:0000050 multivalued: true range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:a x:b ) ) Parts collection with counts Description : _Demonstrates nesting _ Schema : id: http//example.org/Parts-collection-with-counts classes: CollectionOfPartsWithCounts: annotations: owl.template: tag: owl.template value: \"{% for p in has_part %}\\nSubClassOf( {{id}}\\n ObjectSomeValuesFrom(\\ \\ BFO:0000051\\n ObjectIntersectionOf( {{p.unit\\ \\ }}\\n ObjectSomeValuesFrom(RO:0000053\\ \\ {{p.state.meaning}})\\n \\ \\ {% if p.count %}\\n \\ \\ DataHasValue(PATO:0001555 \\\"{{p.count}}\\\"^^xsd:integer )\\n\\ \\ {% endif %}\\n \\ \\ )\\n\\n \\ \\ )\\n )\\n{% endfor %}\" is_a: NamedThing attributes: has_part: slot_uri: BFO:0000051 multivalued: true inlined: true inverse: part_of range: PartWithCounts id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:collection has_part: - unit: x:p1 count: 2 state: ACTIVATED - unit: x:p2 count: 3 state: ACTIVATED Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p1 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"2\"^^xsd:integer ) ) ) ) SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p2 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"3\"^^xsd:integer ) ) ) ) ) Parts collection Description : _Things that are made of an arbitrary list of parts _ Schema : id: http//example.org/Parts-collection classes: CollectionOfParts: annotations: owl.template: tag: owl.template value: \"{% for p in has_part %}\\nSubClassOf( {{id}} ObjectSomeValuesFrom(\\ \\ BFO:0000051 {{p}} ) )\\n{% endfor %}\\nDisjointClasses(\\n Annotation(\\ \\ rdfs:label \\\"all parts of {{id}} are part-disjoint\\\")\\n {% for p in has_part\\ \\ %}\\n ObjectSomeValuesFrom( BFO:0000050 {{p}} )\\n {% endfor %}\\n)\" is_a: NamedThing attributes: has_part: slot_uri: BFO:0000051 multivalued: true inverse: part_of range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:collection has_part: - x:p1 - x:p2 Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 x:p1 ) ) SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 x:p2 ) ) DisjointClasses( Annotation( rdfs:label \"all parts of x:collection are part-disjoint\" ) ObjectSomeValuesFrom( BFO:0000050 x:p1 ) ObjectSomeValuesFrom( BFO:0000050 x:p2 ) ) ) Defined parts collection Description : _Things that are defined exhaustively by an arbitrary list of parts _ Schema : id: http//example.org/Defined-parts-collection classes: DefinedCollectionOfParts: annotations: owl.template: tag: owl.template value: \"EquivalentClasses( {{id}}\\n ObjectIntersectionOf(\\n\\ \\ {% for p in has_part %}\\n ObjectSomeValuesFrom(\\ \\ BFO:0000051 {{p}} )\\n {% endfor %}\\n \\ \\ ObjectAllValuesFrom( BFO:0000051\\n \\ \\ ObjectSomeValuesFrom( BFO:0000050\\n \\ \\ ObjectUnionOf(\\n \\ \\ {% for p in has_part %}\\n \\ \\ ObjectSomeValuesFrom( BFO:0000051 {{p}} )\\n \\ \\ {% endfor %} )\\n \\ \\ )\\n )\\n \\ \\ )\\n )\" is_a: NamedThing attributes: has_part: slot_uri: BFO:0000051 multivalued: true inverse: part_of range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:collection has_part: - x:dp1 - x:dp2 Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( x:collection ObjectIntersectionOf( ObjectSomeValuesFrom( BFO:0000051 x:dp1 ) ObjectSomeValuesFrom( BFO:0000051 x:dp2 ) ObjectAllValuesFrom( BFO:0000051 ObjectSomeValuesFrom( BFO:0000050 ObjectUnionOf( ObjectSomeValuesFrom( BFO:0000051 x:dp1 ) ObjectSomeValuesFrom( BFO:0000051 x:dp2 ) ) ) ) ) ) )","title":"Examples"},{"location":"examples/#linkml-owl-test-cases","text":"These examples are generated automatically from test_owl_dumper For the complete schema, see tests/input/owl_dumper_test.yaml","title":"linkml-owl Test Cases"},{"location":"examples/#annotation-using-literals","text":"Description : Default is to use an annotation assertion, and if the range is a string then this is literal Schema : id: http//example.org/Annotation-using-literals classes: NamedThing: is_a: Thing attributes: id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a label: foo Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( rdfs:label <http://example.org/a> \"foo\" ) )","title":"Annotation using literals"},{"location":"examples/#annotation-using-iris","text":"Description : As above, but if the range is an instance of a LinkML class then use a literal Schema : id: http//example.org/Annotation-using-IRIs classes: ExactMatch: is_a: NamedThing attributes: exactMatch: annotations: owl: AnnotationAssertion slot_uri: skos:exactMatch range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a exactMatch: x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( <http://www.w3.org/2004/02/skos/core#exactMatch> <http://example.org/a> <http://example.org/b> ) )","title":"Annotation using IRIs"},{"location":"examples/#annotation-using-forced-literals","text":"Description : We can force a literal by imposing a range Schema : id: http//example.org/Annotation-using-forced-literals classes: ExactMatchAsLiteral: is_a: NamedThing attributes: exactMatch: annotations: owl: AnnotationAssertion slot_uri: skos:exactMatch range: string required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a exactMatch: x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( <http://www.w3.org/2004/02/skos/core#exactMatch> <http://example.org/a> \"x:b\" ) )","title":"Annotation using forced literals"},{"location":"examples/#basic-subclassof-between-named-classes","text":"Description : _Adding SubClassOf annotation to the linkml class forces a SubClass axiom _ Schema : id: http//example.org/Basic-SubClassOf-between-named-classes classes: Child: is_a: NamedThing attributes: subclass_of: annotations: owl: SubClassOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> <http://example.org/b> ) )","title":"Basic SubClassOf between named classes"},{"location":"examples/#basic-direct-equivalence-between-named-classes","text":"Description : Adding EquivalentTo annotation to the linkml class forces a SubClass axiom Schema : id: http//example.org/basic-direct-equivalence-between-named-classes classes: DirectEquivalent: is_a: NamedThing attributes: equivalent_to: annotations: owl: EquivalentClasses slot_uri: owl:equivalentClasses multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a equivalent_to: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> <http://example.org/b> ) )","title":"basic direct equivalence between named classes"},{"location":"examples/#subclassof-somevaluesfrom","text":"Description : A SubClassOf annotation makes the annotation type be subclass, a SomeValuesFrom annotation makes the slot interpreted as an existential Schema : id: http//example.org/SubClassOf-SomeValuesFrom classes: Part: is_a: NamedThing attributes: part_of: annotations: owl: ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a part_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) )","title":"SubClassOf SomeValuesFrom"},{"location":"examples/#subclassof-allvaluesfrom","text":"Description : As above, but with universal restrictions Schema : id: http//example.org/SubClassOf-AllValuesFrom classes: PartOnly: is_a: NamedThing attributes: part_of: annotations: owl: ObjectAllValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a part_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectAllValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) )","title":"SubClassOf AllValuesFrom"},{"location":"examples/#subclassof-somevaluesfrom-plus-label","text":"Description : Demonstrates a mix of slots, some annotation, some logical Schema : id: http//example.org/SubClassOf-SomeValuesFrom-plus-label classes: Part: is_a: NamedThing attributes: part_of: annotations: owl: ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a label: foo part_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> AnnotationAssertion( rdfs:label <http://example.org/a> \"foo\" ) SubClassOf( <http://example.org/a> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) )","title":"SubClassOf SomeValuesFrom plus label"},{"location":"examples/#subclassof-union","text":"Description : The slot is interpreted as a parent class, and all slot values with a UnionOf annotation are collected to make a UnionOf expression Schema : id: http//example.org/SubClassOf-Union classes: ChildOfUnion: is_a: NamedThing attributes: subclass_of: annotations: owl: SubClassOf, UnionOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectUnionOf( <http://example.org/b> <http://example.org/c> ) ) )","title":"SubClassOf Union"},{"location":"examples/#equivalentto-union","text":"Description : As above, but with equivalence Schema : id: http//example.org/EquivalentTo-Union classes: EquivUnion: is_a: NamedThing attributes: operands: annotations: owl: EquivalentClasses, UnionOf multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a operands: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> ObjectUnionOf( <http://example.org/b> <http://example.org/c> ) ) )","title":"EquivalentTo Union"},{"location":"examples/#equivalentto-intersectionof","text":"Description : The slot is interpreted as a parent class, and all slot values with a IntersectionOf annotation are collected to make a IntersectionOf expression Schema : id: http//example.org/EquivalentTo-IntersectionOf classes: EquivIntersection: is_a: NamedThing attributes: operands: annotations: owl: EquivalentClasses, IntersectionOf multivalued: true range: NamedThing required: true id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a operands: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> ObjectIntersectionOf( <http://example.org/b> <http://example.org/c> ) ) )","title":"EquivalentTo IntersectionOf"},{"location":"examples/#equivalentto-genus-and-somevaluesfrom","text":"Description : All slot value interpretations are collected into a single IntersectionOf Schema : id: http//example.org/EquivalentTo-Genus-and-SomeValuesFrom classes: EquivGenusAndPartOf: is_a: NamedThing attributes: subclass_of: annotations: owl: EquivalentClasses, IntersectionOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true part_of: annotations: owl: EquivalentClasses, IntersectionOf, ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true other_part_ofs: annotations: owl: ObjectSomeValuesFrom description: for hidden GCIs slot_uri: BFO:0000050 multivalued: true range: NamedThing required: false id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - X:genus part_of: - x:b - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( <http://example.org/a> ObjectIntersectionOf( <http://example.org/genus> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/c> ) ) ) )","title":"EquivalentTo Genus and SomeValuesFrom"},{"location":"examples/#hidden-gci","text":"Description : Demonstrates a case where some slots contribute to a logical definition (equiv axiom), and other contribute to additional axioms (so called hidden GCIs) Schema : id: http//example.org/Hidden-GCI classes: EquivGenusAndPartOf: is_a: NamedThing attributes: subclass_of: annotations: owl: EquivalentClasses, IntersectionOf slot_uri: rdfs:subclass_of multivalued: true range: NamedThing required: true part_of: annotations: owl: EquivalentClasses, IntersectionOf, ObjectSomeValuesFrom slot_uri: BFO:0000050 multivalued: true range: NamedThing required: true other_part_ofs: annotations: owl: ObjectSomeValuesFrom description: for hidden GCIs slot_uri: BFO:0000050 multivalued: true range: NamedThing required: false id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - X:genus part_of: - x:b other_part_ofs: - x:c Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( <http://example.org/a> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/c> ) ) EquivalentClasses( <http://example.org/a> ObjectIntersectionOf( <http://example.org/genus> ObjectSomeValuesFrom( <http://purl.obolibrary.org/obo/BFO_0000050> <http://example.org/b> ) ) ) )","title":"Hidden GCI"},{"location":"examples/#slot-value-level-fstring-template","text":"Description : Axiom generation per slot-value assignment. (Note that currently non-identifier fields have their URIs expanded, but the OWL is the same) Schema : id: http//example.org/slot-value-level-fstring-template classes: ClassTemplateExample1: is_a: NamedThing attributes: subclass_of: annotations: owl.fstring: tag: owl.fstring value: SubClassOf({id} {V}) slot_uri: rdfs:subclass_of multivalued: true range: NamedThing part_of: slot_uri: BFO:0000050 multivalued: true range: NamedThing other_part_ofs: slot_uri: BFO:0000050 multivalued: true range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:a <http://example.org/b> ) )","title":"slot-value level fstring template"},{"location":"examples/#slot-value-level-jinja-template","text":"Description : Axiom generation per slot-value assignment. (Note that currently non-identifier fields have their URIs expanded, but the OWL is the same) Schema : id: http//example.org/slot-value-level-jinja-template classes: ClassTemplateExample2: is_a: NamedThing attributes: subclass_of: annotations: owl.template: tag: owl.template value: '{% for p in subclass_of %}SubClassOf({{id}} {{p}}){% endfor %}' slot_uri: rdfs:subclass_of multivalued: true range: NamedThing part_of: slot_uri: BFO:0000050 multivalued: true range: NamedThing other_part_ofs: slot_uri: BFO:0000050 multivalued: true range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:a subclass_of: - x:b Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:a x:b ) )","title":"slot-value level jinja template"},{"location":"examples/#parts-collection-with-counts","text":"Description : _Demonstrates nesting _ Schema : id: http//example.org/Parts-collection-with-counts classes: CollectionOfPartsWithCounts: annotations: owl.template: tag: owl.template value: \"{% for p in has_part %}\\nSubClassOf( {{id}}\\n ObjectSomeValuesFrom(\\ \\ BFO:0000051\\n ObjectIntersectionOf( {{p.unit\\ \\ }}\\n ObjectSomeValuesFrom(RO:0000053\\ \\ {{p.state.meaning}})\\n \\ \\ {% if p.count %}\\n \\ \\ DataHasValue(PATO:0001555 \\\"{{p.count}}\\\"^^xsd:integer )\\n\\ \\ {% endif %}\\n \\ \\ )\\n\\n \\ \\ )\\n )\\n{% endfor %}\" is_a: NamedThing attributes: has_part: slot_uri: BFO:0000051 multivalued: true inlined: true inverse: part_of range: PartWithCounts id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:collection has_part: - unit: x:p1 count: 2 state: ACTIVATED - unit: x:p2 count: 3 state: ACTIVATED Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p1 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"2\"^^xsd:integer ) ) ) ) SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p2 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"3\"^^xsd:integer ) ) ) ) )","title":"Parts collection with counts"},{"location":"examples/#parts-collection","text":"Description : _Things that are made of an arbitrary list of parts _ Schema : id: http//example.org/Parts-collection classes: CollectionOfParts: annotations: owl.template: tag: owl.template value: \"{% for p in has_part %}\\nSubClassOf( {{id}} ObjectSomeValuesFrom(\\ \\ BFO:0000051 {{p}} ) )\\n{% endfor %}\\nDisjointClasses(\\n Annotation(\\ \\ rdfs:label \\\"all parts of {{id}} are part-disjoint\\\")\\n {% for p in has_part\\ \\ %}\\n ObjectSomeValuesFrom( BFO:0000050 {{p}} )\\n {% endfor %}\\n)\" is_a: NamedThing attributes: has_part: slot_uri: BFO:0000051 multivalued: true inverse: part_of range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:collection has_part: - x:p1 - x:p2 Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 x:p1 ) ) SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 x:p2 ) ) DisjointClasses( Annotation( rdfs:label \"all parts of x:collection are part-disjoint\" ) ObjectSomeValuesFrom( BFO:0000050 x:p1 ) ObjectSomeValuesFrom( BFO:0000050 x:p2 ) ) )","title":"Parts collection"},{"location":"examples/#defined-parts-collection","text":"Description : _Things that are defined exhaustively by an arbitrary list of parts _ Schema : id: http//example.org/Defined-parts-collection classes: DefinedCollectionOfParts: annotations: owl.template: tag: owl.template value: \"EquivalentClasses( {{id}}\\n ObjectIntersectionOf(\\n\\ \\ {% for p in has_part %}\\n ObjectSomeValuesFrom(\\ \\ BFO:0000051 {{p}} )\\n {% endfor %}\\n \\ \\ ObjectAllValuesFrom( BFO:0000051\\n \\ \\ ObjectSomeValuesFrom( BFO:0000050\\n \\ \\ ObjectUnionOf(\\n \\ \\ {% for p in has_part %}\\n \\ \\ ObjectSomeValuesFrom( BFO:0000051 {{p}} )\\n \\ \\ {% endfor %} )\\n \\ \\ )\\n )\\n \\ \\ )\\n )\" is_a: NamedThing attributes: has_part: slot_uri: BFO:0000051 multivalued: true inverse: part_of range: NamedThing id: identifier: true range: uriorcurie label: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: rdfs:label definition: annotations: owl: AnnotationProperty, AnnotationAssertion slot_uri: IAO:0000115 Input : - id: x:collection has_part: - x:dp1 - x:dp2 Generated axioms : Prefix( xml: = <http://www.w3.org/XML/1998/namespace> ) Prefix( rdf: = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ) Prefix( rdfs: = <http://www.w3.org/2000/01/rdf-schema#> ) Prefix( xsd: = <http://www.w3.org/2001/XMLSchema#> ) Prefix( owl: = <http://www.w3.org/2002/07/owl#> ) Ontology( <https://w3id.org/linkml/owl/tests> EquivalentClasses( x:collection ObjectIntersectionOf( ObjectSomeValuesFrom( BFO:0000051 x:dp1 ) ObjectSomeValuesFrom( BFO:0000051 x:dp2 ) ObjectAllValuesFrom( BFO:0000051 ObjectSomeValuesFrom( BFO:0000050 ObjectUnionOf( ObjectSomeValuesFrom( BFO:0000051 x:dp1 ) ObjectSomeValuesFrom( BFO:0000051 x:dp2 ) ) ) ) ) ) )","title":"Defined parts collection"},{"location":"further-reading/","text":"See Also OWL Generator in the LinkML core generates OWL from Schemas, not data rdflib_dumper in linkml-runtime generates RDF graphs (ABoxes) from LinkML instances graphs using a standard 1:1 mapping","title":"Further reading"},{"location":"further-reading/#see-also","text":"OWL Generator in the LinkML core generates OWL from Schemas, not data rdflib_dumper in linkml-runtime generates RDF graphs (ABoxes) from LinkML instances graphs using a standard 1:1 mapping","title":"See Also"},{"location":"mappings/","text":"Mapping Vocabulary Use the following keywords to annotate your schema elements: Slots Axiom type designators SubClassOf EquivalentClasses AnnotationAssertion ... Expression modifier designators ObjectSomeValuesFrom ObjectAllValuesFrom ... Collection type designators ObjectIntersectionOf ObjectUnionOf ... Classes Class Individual ...","title":"Mappings"},{"location":"mappings/#mapping-vocabulary","text":"Use the following keywords to annotate your schema elements: Slots Axiom type designators SubClassOf EquivalentClasses AnnotationAssertion ... Expression modifier designators ObjectSomeValuesFrom ObjectAllValuesFrom ... Collection type designators ObjectIntersectionOf ObjectUnionOf ... Classes Class Individual ...","title":"Mapping Vocabulary"},{"location":"specification/","text":"Formalism (EARLY DRAFT) THIS IS OUT OF DATE REGARDING THE CURRENT IMPLEMENTATION A LinkML model M consists of: slots MS = {s1, ...} classes MC = {c1,...} enums MEn = {En1, ...} types MT = {t1, ...} subsets MSu = {su1, ..} Each slot s \u2208 MS and each class c \u2208 MC has an interpretation \u0394: \u0394(s) \u2208 P( {SubClassOf, ClassAssertion, SomeValuesFrom, AllValuesFrom, AnnotationAssertion, ObjectPropertyAssertion, AnnotationPropertyAssertion, UnionOf, DataOneOf, ObjectOneOf } ) \u0394(c) \u2208 P( {Class, Individual, ObjectProperty, DataProperty, AnnotationAssertion} ) (here P denotes the powerset, i.e. \u0394 maps to class or slot to a set of valid terms) The interpretation dictates how elements that instantiate the model are translated to OWL-DL Informative note: any class c \u2208 MC where Class \u2208 \u0394(c) is considered a metaclass any class c \u2208 MC where *Property \u2208 \u0394(c) is considered a metaproperty in the linkml metamodel, the class ClassDefinition is a metaclass A LinkML element e \u2208 E is either: An instance of a class in MC A reference to an instance of a class in MC A literal taken from the universe of literals L A permissible value from the set of permissible values of a member of MEn Note that the distinction between 1 and 2 only holds for tree representations such as YAML and JSON serializations. Each e has a set of slot-value assignments A(e) , where each assignment is a pair s, V s is a slot in MS V is a list of elements v1, ..., vn each of which can be: if s.range \u2208 MT : v_i must be a Literal if s.range \u2208 MC : v_i must be either: another element in I OR a reference to an element in I (this distinction only holds for yaml/json tree representations) if s.range \u2208 MEn : v_i must be a member of the permissible value in ME A(i) \u2286 { (s,V) \u2208 MS x I \u222a Ref(I) \u222a ME \u222a L } Any slot marked as identifier is not considered among the list of slots. The identifier slot for a class c is marked c.id The identifier value for an element e is marked e.id Only elements that instantiate classes in MC can have identifiers. Not all instantiating elements have identifiers - instantiating elements without anonymous Any linkml element can be translated using the rules below. The translation is recursive, i.e. mapping an element that has slot-value associations will invoke mappings on the values of these associations. If the linkml element graph is a tree, then invoking mapping on the root will map the whole graph Mapping elements The function Tr(e) will translate an element e to an OWL entity , and as a side-effect will generate OWL axioms Table 1: Translation of elements to OWL entities condition returns e.type \u2208 MC and hasId(e) IRI(e.id) e.type \u2208 MC and noId(e) BlankNode() e.type \u2208 Ref(MC) IRI(e) e.type \u2208 MEn IRI(e.meaning) e.type \u2208 T Literal(e) Generation of OWL axioms Invoking Tr(e) will additionally generate further OWL axioms: for all (s,V) in A(e) , a mapping Tr(e,s,V) is applied See mapping slot values below. Generation of OWL declarations TODO Function \u0394(e.type) generates cond C(i) * Class(IRI(i.id)) i.id exists OP(i) * ObjectProperty(IRI(i.id)) i.id exists DP(i) * DataProperty(IRI(i.id)) i.id exists AP(i) * AnnotationProperty(IRI(i.id)) i.id exists *|*| BlankNode(i) | i.id` not exists Mapping slot values: Tr(i,s,V) interpretation of an element i with slot s with values V=v1..vn Table 2: single-valued or conjunctive lists If s is not multivalued OR {UnionOf, DataOneOf, ObjectOneOf} \u2229 \u0394(s) = {} then the following table generates an axiom for all v \u2208 V \u0394(e.type) \u0394(s) expression cond * SubClassOf \u2208 \u0394 C(e) \u2291 C(v) * SubObjectPropertyOf \u2208 \u0394 OP(e) \u2291 OP(v) * ClassAssertion \u2208 \u0394 I(e) : C(v) Class SomeValuesFrom \u2208 \u0394 C(e) \u2291 \u2203 OP(s) C(v) Class AllValuesFrom \u2208 \u0394 C(e) \u2291 \u2200 OP(s) C(v) Individual SomeValuesFrom \u2208 \u0394 I(e) : \u2203 OP(s) C(v) Individual AllValuesFrom \u2208 \u0394 I(e) : \u2200 OP(s) C(v) * AnnotationAssertion \u2208 \u0394 OR \u0394 = {} Ann(P(s) IRI(e) Tr(v)) * ObjectPropertyAssertion \u2208 \u0394 OPA(OP(s) IRI(e) Tr(v)) * DataPropertyAssertion \u2208 \u0394 DPA(DP(s) IRI(e) Tr(v)) See DL article on Wikipedia for explanation of symbols multi-valued or disjunctive lists If s is multivalued AND {UnionOf, DataOneOf, ObjectOneOf} \u2229 \u0394(s) \u2260 {} then apply the following steps, and then apply table 2 rules \u0394(s) Tr(V) UnionOf \u2208 \u0394 UnionOf(C(v1), ..., C(vn)) ObjectOneOf \u2208 \u0394 ObjectOneOf(I(v1), ..., I(vn)) DataOneOf \u2208 \u0394 DataOneOf(D(v1), ..., D(vn)) pre-processing For uncommitted slots that have a slot iri with a pre-existing interpretation, these are used: If s.iri = rdf:type , and \u0394(s) = {} then set \u0394(s) = {ClassAssertion} If s.iri = rdfs:subClassOf , and \u0394(s) = {} then set \u0394(s) = {SubClassOf} etc TODO","title":"Specification"},{"location":"specification/#formalism-early-draft","text":"THIS IS OUT OF DATE REGARDING THE CURRENT IMPLEMENTATION A LinkML model M consists of: slots MS = {s1, ...} classes MC = {c1,...} enums MEn = {En1, ...} types MT = {t1, ...} subsets MSu = {su1, ..} Each slot s \u2208 MS and each class c \u2208 MC has an interpretation \u0394: \u0394(s) \u2208 P( {SubClassOf, ClassAssertion, SomeValuesFrom, AllValuesFrom, AnnotationAssertion, ObjectPropertyAssertion, AnnotationPropertyAssertion, UnionOf, DataOneOf, ObjectOneOf } ) \u0394(c) \u2208 P( {Class, Individual, ObjectProperty, DataProperty, AnnotationAssertion} ) (here P denotes the powerset, i.e. \u0394 maps to class or slot to a set of valid terms) The interpretation dictates how elements that instantiate the model are translated to OWL-DL Informative note: any class c \u2208 MC where Class \u2208 \u0394(c) is considered a metaclass any class c \u2208 MC where *Property \u2208 \u0394(c) is considered a metaproperty in the linkml metamodel, the class ClassDefinition is a metaclass A LinkML element e \u2208 E is either: An instance of a class in MC A reference to an instance of a class in MC A literal taken from the universe of literals L A permissible value from the set of permissible values of a member of MEn Note that the distinction between 1 and 2 only holds for tree representations such as YAML and JSON serializations. Each e has a set of slot-value assignments A(e) , where each assignment is a pair s, V s is a slot in MS V is a list of elements v1, ..., vn each of which can be: if s.range \u2208 MT : v_i must be a Literal if s.range \u2208 MC : v_i must be either: another element in I OR a reference to an element in I (this distinction only holds for yaml/json tree representations) if s.range \u2208 MEn : v_i must be a member of the permissible value in ME A(i) \u2286 { (s,V) \u2208 MS x I \u222a Ref(I) \u222a ME \u222a L } Any slot marked as identifier is not considered among the list of slots. The identifier slot for a class c is marked c.id The identifier value for an element e is marked e.id Only elements that instantiate classes in MC can have identifiers. Not all instantiating elements have identifiers - instantiating elements without anonymous Any linkml element can be translated using the rules below. The translation is recursive, i.e. mapping an element that has slot-value associations will invoke mappings on the values of these associations. If the linkml element graph is a tree, then invoking mapping on the root will map the whole graph","title":"Formalism (EARLY DRAFT)"},{"location":"specification/#mapping-elements","text":"The function Tr(e) will translate an element e to an OWL entity , and as a side-effect will generate OWL axioms","title":"Mapping elements"},{"location":"specification/#table-1-translation-of-elements-to-owl-entities","text":"condition returns e.type \u2208 MC and hasId(e) IRI(e.id) e.type \u2208 MC and noId(e) BlankNode() e.type \u2208 Ref(MC) IRI(e) e.type \u2208 MEn IRI(e.meaning) e.type \u2208 T Literal(e)","title":"Table 1: Translation of elements to OWL entities"},{"location":"specification/#generation-of-owl-axioms","text":"Invoking Tr(e) will additionally generate further OWL axioms: for all (s,V) in A(e) , a mapping Tr(e,s,V) is applied See mapping slot values below.","title":"Generation of OWL axioms"},{"location":"specification/#generation-of-owl-declarations","text":"TODO Function \u0394(e.type) generates cond C(i) * Class(IRI(i.id)) i.id exists OP(i) * ObjectProperty(IRI(i.id)) i.id exists DP(i) * DataProperty(IRI(i.id)) i.id exists AP(i) * AnnotationProperty(IRI(i.id)) i.id exists *|*| BlankNode(i) | i.id` not exists","title":"Generation of OWL declarations"},{"location":"specification/#mapping-slot-values-trisv","text":"interpretation of an element i with slot s with values V=v1..vn","title":"Mapping slot values: Tr(i,s,V)"},{"location":"specification/#table-2-single-valued-or-conjunctive-lists","text":"If s is not multivalued OR {UnionOf, DataOneOf, ObjectOneOf} \u2229 \u0394(s) = {} then the following table generates an axiom for all v \u2208 V \u0394(e.type) \u0394(s) expression cond * SubClassOf \u2208 \u0394 C(e) \u2291 C(v) * SubObjectPropertyOf \u2208 \u0394 OP(e) \u2291 OP(v) * ClassAssertion \u2208 \u0394 I(e) : C(v) Class SomeValuesFrom \u2208 \u0394 C(e) \u2291 \u2203 OP(s) C(v) Class AllValuesFrom \u2208 \u0394 C(e) \u2291 \u2200 OP(s) C(v) Individual SomeValuesFrom \u2208 \u0394 I(e) : \u2203 OP(s) C(v) Individual AllValuesFrom \u2208 \u0394 I(e) : \u2200 OP(s) C(v) * AnnotationAssertion \u2208 \u0394 OR \u0394 = {} Ann(P(s) IRI(e) Tr(v)) * ObjectPropertyAssertion \u2208 \u0394 OPA(OP(s) IRI(e) Tr(v)) * DataPropertyAssertion \u2208 \u0394 DPA(DP(s) IRI(e) Tr(v)) See DL article on Wikipedia for explanation of symbols","title":"Table 2: single-valued or conjunctive lists"},{"location":"specification/#multi-valued-or-disjunctive-lists","text":"If s is multivalued AND {UnionOf, DataOneOf, ObjectOneOf} \u2229 \u0394(s) \u2260 {} then apply the following steps, and then apply table 2 rules \u0394(s) Tr(V) UnionOf \u2208 \u0394 UnionOf(C(v1), ..., C(vn)) ObjectOneOf \u2208 \u0394 ObjectOneOf(I(v1), ..., I(vn)) DataOneOf \u2208 \u0394 DataOneOf(D(v1), ..., D(vn))","title":"multi-valued or disjunctive lists"},{"location":"specification/#pre-processing","text":"For uncommitted slots that have a slot iri with a pre-existing interpretation, these are used: If s.iri = rdf:type , and \u0394(s) = {} then set \u0394(s) = {ClassAssertion} If s.iri = rdfs:subClassOf , and \u0394(s) = {} then set \u0394(s) = {SubClassOf} etc TODO","title":"pre-processing"},{"location":"templates/","text":"Templates and Fstrings The previous method of annotating slots with OWL interpretations works well for cases where there is a relatively straightforward mapping between slots and axioms. For full grained control you can use either formatted strings , e.g. SubClassOf({id} {sublass_of}) , for cases with no or minimal logic Jinja templates , for cases where control logic or advanced mappings are required Either of these methods can be used to make either annotations or logical axioms Here is an example of a more advanced schema involving nesting where we might want to model parts with counts - examples include reaction participants with stoichiometry, or protein complexes where members may be present with different counts or activation states: PartWithCounts: is_a: Anonymous attributes: unit: range: NamedThing multivalued: false annotations: owl: SomeValuesFrom count: range: integer minimum_value: 1 annotations: owl: HasValue state: range: ActivationStateEnum annotations: owl: SomeValuesFrom CollectionOfPartsWithCounts: is_a: NamedThing slots: - has_part slot_usage: has_part: range: PartWithCounts inlined: true annotations: owl.template: |- {% for p in has_part %} SubClassOf( {{id}} ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( {{p.unit }} ObjectSomeValuesFrom(RO:0000053 {{p.state.meaning}}) {% if p.count %} DataHasValue(PATO:0001555 {{p.count}}) {% endif %} ) ) ) {% endfor %} Given an input file: id: x:collection has_part: - unit: x:p1 count: 2 state: ACTIVATED - unit: x:p2 count: 3 state: ACTIVATED (note that we use using nesting / a normalized representation here, this is harder to represent in a spreadsheet/TSV). This will generate the following OWL: SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p1 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"2\"^^xsd:integer )))) SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p2 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"3\"^^xsd:integer ))))","title":"Templates"},{"location":"templates/#templates-and-fstrings","text":"The previous method of annotating slots with OWL interpretations works well for cases where there is a relatively straightforward mapping between slots and axioms. For full grained control you can use either formatted strings , e.g. SubClassOf({id} {sublass_of}) , for cases with no or minimal logic Jinja templates , for cases where control logic or advanced mappings are required Either of these methods can be used to make either annotations or logical axioms Here is an example of a more advanced schema involving nesting where we might want to model parts with counts - examples include reaction participants with stoichiometry, or protein complexes where members may be present with different counts or activation states: PartWithCounts: is_a: Anonymous attributes: unit: range: NamedThing multivalued: false annotations: owl: SomeValuesFrom count: range: integer minimum_value: 1 annotations: owl: HasValue state: range: ActivationStateEnum annotations: owl: SomeValuesFrom CollectionOfPartsWithCounts: is_a: NamedThing slots: - has_part slot_usage: has_part: range: PartWithCounts inlined: true annotations: owl.template: |- {% for p in has_part %} SubClassOf( {{id}} ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( {{p.unit }} ObjectSomeValuesFrom(RO:0000053 {{p.state.meaning}}) {% if p.count %} DataHasValue(PATO:0001555 {{p.count}}) {% endif %} ) ) ) {% endfor %} Given an input file: id: x:collection has_part: - unit: x:p1 count: 2 state: ACTIVATED - unit: x:p2 count: 3 state: ACTIVATED (note that we use using nesting / a normalized representation here, this is harder to represent in a spreadsheet/TSV). This will generate the following OWL: SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p1 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"2\"^^xsd:integer )))) SubClassOf( x:collection ObjectSomeValuesFrom( BFO:0000051 ObjectIntersectionOf( x:p2 ObjectSomeValuesFrom( RO:0000053 <http://purl.obolibrary.org/obo/PATO_0002354> ) DataHasValue( PATO:0001555 \"3\"^^xsd:integer ))))","title":"Templates and Fstrings"},{"location":"tips/","text":"Assorted tips and best practices IDE support for ontology authoring If you are entering data in either YAML or JSON (YAML is recommended), then you can get IDE support (e.g. autocomplete on tag names) Convert your schema to jsonschema using gen-schema Load this into your IDE When editing your yaml data file, set the schema For info on how to do this with PyCharm see these slides Provide rich documentation LinkML provides a rich metamodel for providing metadata about your design pattern elements. You can provide provenance (e.g who authored it), status information, editor-level docs, end-user level docs, etc See schema element metadata Minimally, we recommend providing at least description fields for all slots and all classes Validating data We recommend validating: input data, using linkml data validation output owl ontologies, using robot internal consistency of the schema (pattern templates) If source data is managed in github, set up github actions to validate See validating data in the main linkml guide We recommend you constrain things as strictly as possible For example, use enums for smaller value sets Classes in your schema can be declared disjoint ( note this is distinct from disjointness axioms for generated classes ) Declare ranges for all slots Use pattern to constraint string values Auto-filling in data The linkml-owl framework does not provide extensive mechanisms for auto-filling data. Here auto-filling means: assigning default values assigning string fields based on format strings These are considered separate concerns from mapping to OWL, and can be done upstream of linkml-owl, including in the linkml framework itself. However, if you are using the jinja template generation route, you can also do a lot of auto-filling using jinja template logic","title":"Tips"},{"location":"tips/#assorted-tips-and-best-practices","text":"","title":"Assorted tips and best practices"},{"location":"tips/#ide-support-for-ontology-authoring","text":"If you are entering data in either YAML or JSON (YAML is recommended), then you can get IDE support (e.g. autocomplete on tag names) Convert your schema to jsonschema using gen-schema Load this into your IDE When editing your yaml data file, set the schema For info on how to do this with PyCharm see these slides","title":"IDE support for ontology authoring"},{"location":"tips/#provide-rich-documentation","text":"LinkML provides a rich metamodel for providing metadata about your design pattern elements. You can provide provenance (e.g who authored it), status information, editor-level docs, end-user level docs, etc See schema element metadata Minimally, we recommend providing at least description fields for all slots and all classes","title":"Provide rich documentation"},{"location":"tips/#validating-data","text":"We recommend validating: input data, using linkml data validation output owl ontologies, using robot internal consistency of the schema (pattern templates) If source data is managed in github, set up github actions to validate See validating data in the main linkml guide We recommend you constrain things as strictly as possible For example, use enums for smaller value sets Classes in your schema can be declared disjoint ( note this is distinct from disjointness axioms for generated classes ) Declare ranges for all slots Use pattern to constraint string values","title":"Validating data"},{"location":"tips/#auto-filling-in-data","text":"The linkml-owl framework does not provide extensive mechanisms for auto-filling data. Here auto-filling means: assigning default values assigning string fields based on format strings These are considered separate concerns from mapping to OWL, and can be done upstream of linkml-owl, including in the linkml framework itself. However, if you are using the jinja template generation route, you can also do a lot of auto-filling using jinja template logic","title":"Auto-filling in data"},{"location":"usage/","text":"Installation and Usage Installation pip install linkml-owl Usage Minimally you need to specify two inputs: A linkml schema , with annotations describing mappings from data to OWL A datafile in YAML, JSON, RDF, or TSV conformant with the schema To convert: linkml-data2owl -s my_schema.yaml my_data.{yaml,json,tsv,rdf} -o my_ontology.owl.ttl For all options, see: linkml-data2owl --help","title":"Usage"},{"location":"usage/#installation-and-usage","text":"","title":"Installation and Usage"},{"location":"usage/#installation","text":"pip install linkml-owl","title":"Installation"},{"location":"usage/#usage","text":"Minimally you need to specify two inputs: A linkml schema , with annotations describing mappings from data to OWL A datafile in YAML, JSON, RDF, or TSV conformant with the schema To convert: linkml-data2owl -s my_schema.yaml my_data.{yaml,json,tsv,rdf} -o my_ontology.owl.ttl For all options, see: linkml-data2owl --help","title":"Usage"}]}